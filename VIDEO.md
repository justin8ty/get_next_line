Hi Hi ! So I'm making a short video to talk about one of the first projects we do as a student at 42, which is the get_next_line project, and I'm making a video on it because I had a little trouble beginning to understand the subject, to understand what was expected of us, and to move forward on it, and I told myself that a short explanatory video could not hurt and that if it could help some of my comrades it was cool.

So what is get_next_line? This is a project that asks us to write a function that returns a line read from a file descriptor. File descriptors, abbreviated as "fd", we saw them in libft because there are certain functions that used this notion, but if you have not yet managed to visualize, the file descriptor in fact is a reference that points to a file that is open on your computer. So as we can see in the prototype of the function, the get_next_line function, we send it this file descriptor, so the reference to a file, we tell it go see in there, and this function must return a string of characters, which will be the line that was read from the file.

That's a little bit what bugged me at first because the project is called get_next_line, so the *next* line, and you just have to assume that at the start, the first time you call this function on a file, the "next line" will be the first line of the file and as explained in the subject, you should be able to read the entire file calling get_next_line on a loop on the same file. So on the first call it will return the first line of the file and each time you call it again on this file it will send the "next line" so line number 2, line number 3, until there are no more.

So the return values, as we have just seen if all goes well it returns the line that was read. And if there is nothing more to read in the file, so if we have already read everything, or if there is an error while this function is running, it will return NULL. And the external functions that can use to code this function are read(), which we don't know yet but is super interesting, malloc() and free(), which we know.

So the notions that we are dealing with that are new in this project are the read() function that we will see right after, the static variables, which the subject advises to go and have a look at what those are, and I imagine you have already done it if you are on this video, and another function that is not in the subject and that I will not explain either, the open() function. I don't explain it because in fact you have lots of great videos on Youtube, well "lots", I found several of them, which explain how in C you can access your files and open and access their content, and it will explain this function, so this function will be useful for you in your main() to call get_next_line and to do your tests, and I think you don't need me to make a video on it, it is quite simple even with the man I think you will really manage to understand how it works.

The one that gave me a little more trouble to visualize is read(). So if we look at the prototype of read() we see that it returns a size_t, an integer, and that it requires that we send a file descriptor to it, so an integer, a pointer to void which will be which is called "buf" but which is a buffer, and a second size_t which is a number of bytes. So in the description we see that read() is trying to read n bytes, so the number of bytes sent to it, in the object referenced by the file descriptor to the buffer pointed to by buf. So read() it will just do that, it will read from a file and store what it read in a variable.

What is interesting with read() and what must be well visualized, and we can see it in the second part of the description, is that in fact it works with a reading head, "pointer" in the man English, that is to say, you have to visualize it a little bit like the cursor you know in word processing software like Word, it's this little bar that flashes and that you actually move forward as you go as you go through your file. And well read() it works the same, so in fact when you call it for the first time on a file, this little bar it will be before the first character of your file if there is text in it, if there are characters, it will be in position before anything, at the very beginning.

And when you tell it "I want you to read n bytes", let's imagine that this nbyte is equal to 5, you tell it "I want you to read 5 bytes" so it will advance its reading head by five bytes, five characters here, forward, so to the right if you are visualising it the same way I am, and it will store these five characters in a buffer that we will have sent to it, we will say "I want you to store this in there", and at the end it will return the number of bytes it managed to read. And that's all.

So we can see in the return values: if all goes well it returns the number of bytes it managed to read and when it gets to the end of the file it returns 0, and if there is a problem it returns -1. So I made you a little diagram to try to represent it a little bit, so you can visualize what I just said, and I added the prototype of the function. So we see in there that we have this file in which I wrote the text "Hello Dolly." the dollar ($) is a newline, and below "Goodbye". I didn't know in fact maybe I should have put the keyboard sign there, the little arrow that curves to the back, but hey I put what is displayed in the terminal when you display a file. So we have that with the text in it, we have the buffer that we send to it, and we have the number of bytes that we want it to read.

So you see at the beginning I represented the playhead in the file by a small vertical red bar, which is in fact our cursor, So we will call read() on this file, what will it do? It will shift its reading head to the right by the number of bytes we want, so here it's 5, we're the ones who set it, we tell it "I want you to read 5" and it's going to store the 5 bytes it read in the buffer given to it. And there you go, she's happy she did her job she returns 5. "Hi, I managed to read 5 bytes in your thing, I'm sending you 5" and that's it, that's what the read() functions does, and if you call it again, and that's where it's important to visualize, in fact read() remembers the position of the cursor, in fact it associates it with the file descriptor, so if you call read() on the same file, on the same file descriptor, the cursor is going to stay in the same place, and the function knows it's already read all of that, so when you ask it to read 5 again, like I just did, it will shift 5 to the right from where it last stopped.

Which it just did. It stores its 5 bytes, here characters, in the buffer, and it returns 5. And so on, if you call it in a loop, there boom it reread 5 characters, including the return to the line, it stores them in the buffer and it returns 5. So here you see the buffer that we send to it, if we make a loop it will always be the same the same place in our memory so it will write over it. It's going to send 5, I call back, I shift 5 to the right, it puts the 5 bytes back in my buffer, it returns 5 and there we see that we're still reaching the end of the file so we call her back, she shifts how much to the right? It is asked to read 5 but there are not 5 so in fact it reads what it can, it reads until the end, so it copies what it has managed to read into the buffer and it returns the number of bytes that it managed to read, i.e. 1, and that's why when it has finished reading a file it returns 0, that's the return value, if I call it back on this file it will send me 0 because it will have succeeded in reading 0 bytes, because it will have already arrived at the end of the file.

So remember that, because it can help you do your tests. And so that's really how it works, it's to help you visualize how this function works. If it's still a little blurry, either I suck at explaining or I invite you to re-watch this sequence because, well obviously I did the project so it's clear but might not be for you. But how to use this function in the context of get_next_line, which asks us as we saw at the beginning of the video to return a character string which corresponds to the line which is read in the file. So again I put get_next_line with its little prototype, the file which is the same file as what we just did, our buffer, and our number of bytes that we will want to read each time.

You saw in the subject the size of the buffer will be defined at compilation, so its size can vary and it is at compilation you will directly tell read() how much you want to read in the file. Here it is, I'm telling you this so you can keep this in mind, and so we're going to have get_next_line, we're going to use read() in it on our file. I call read() on this file, I move forward, here it just happens that I had defined a BUFFER_SIZE of 5 for example, it is our nbytes so it will read 5 bytes, store it in the buffer that it will have been given to read() and read() returns 5, it has finished his work.

What happens from there? In fact, it's not enough for us, because as we've seen each time it's already going to be called it's going to overwrite the buffer, it's going to transfer the characters it read back into the same buffer, so what's going to we have to do already is to recover that, and put it elsewhere to put it aside. So for example we can think of creating a variable called "stash", which can take the form you want actually because it's one of the several ways to work on get_next_line. I did it in several ways because I did the project several times to practice. Either you can store everything in a single variable, I mean either you can store in a string or you can store in a linked list. I did both, the linked lists have certain advantages in terms of execution speed, but anyway what interests us is to store what was in the buffer when reading thanks to read() so we can keep it, so that's what we're going to do. Any way you want, you throw that aside, and actually get_next_line, as we know we want to return a whole line and the subject tells us to read only what we need to read in the file, we can't read the whole file and then parse it and split it into individual lines, so every time we read something in get_next_line we'll look at what's in there and say "Wow wait, wouldn't there be a little newline in there, did I get to the end of a line?". So you look in your stash to see if you have reached the end of a line. The way to do that, well, it's not very complicated, I'll let you find out.

There we see that there is no newline so very well we will be able to continue our work and we call read(). Again it'll shift the playhead 5 to the right, put that in our buffer where "Hello" was before, return 5 because she's happy she returned 5, and again we'll put that in our stash with the technique that we prefer, and once again we look in there, see if there is a newline in there, did I reach the end of the line? Well no it's good, we start again, we call read(), we read 5 bytes, we put that in buffer, we return 5, we put that in our stash, and here once again, as with each call, we look at what's inside, and there surprise, there is a line break in the characters that we read in our file.

So what happens in this case, and well obviously in fact we will want, from the moment we know that we are reaching the end of the line, we will want to extract this line from our reserve in order to be able to return it with get_next_line, it's the goal of the function, so we may have a variable called line, in which we will extract what interests us (the characters and the line break at the end, as it is specified in the subject that it is necessary to return to the line break at the end), and then perhaps what one will want to do once that we know that that segment was already returned is to remove it from our stash, because stash is just for storing stuff that we haven't sent back yet, so we're gonna do a little cleanup with your preferred technique, it's up to you to implement it as you wish, but in any case we will clean up what we had put aside because we no longer need it, and get_next_line will return the value of line[ ] because it has reached the end of the line it is happy. 

So there you go, the topic says, again, that if you call get_next_line on the same file multiple times or up to the end of that file until it's fully read, it will read you all the lines line by line , get_next_line will return you one line at a time. So let's imagine that's what we're going to do here. The thing, and this is where it gets interesting and where we're going to tackle another notion that we haven't seen yet, is that if I call get_next_line again with the variables that I declared as I have them declared, what happens, actually we see that the cursor stays in the same place, this we saw earlier, read(), the reading head in our file stays where it was because it is associated with the file descriptor. So here we already know that get_next_line returned the first line "Hello Dolly$" and that read() read until after "Go", and that it was in our stash, we cleaned our stash, but except that when we come back with get_next_line, the stash variable is reinitialized because it was emptied when we sent the line[ on the previous call, and this is where a super interesting notion comes into play, which is in fact the static variables.

A static variable is a variable that will keep its value between two function calls. So there stash was declared in get_next_line, and when we go to make it static, what will happen when we go back to get_next_line on the second pass is that we will have "Go" which will be back, which will be kept. So we actually kept everything we read with read(). Because once again we can't go back with read(), and it's specified in the subject we don't have the right to use the lseek() function for example, which allows us to move the cursor as you want, so here you have to be able to store everything you have read. There you go, static. So for example here we call read(), it shifts 5 to the right, read() will return 5, and again we will be able to put what we had in our buffer in our smash, in the way we prefer, check our stash for a newline etc, etc... And that's how get_next_line works. 

That's it, so I hope this little video has been useful for you to better understand the subject, better understand it and to think about the way you prefer to write this code. If I said something stupid or I explained something badly, or I forgot something, do not hesitate to indicate it in the comments for the others, so go see the comments, and if ever this video was useful to you, don't hesitate to let me know because it's nice and above all, if someone has trouble moving forward on this or understanding the project, don't hesitate to send it to them. 

As I said I did this project twice so I did several techniques to manage my variables, and in fact I forced myself, because there is one of the techniques which is to use linked lists, which I had not done in my piscine, and it was super vague, and I was a little afraid of linked lists, and I know that in C they're super important and that we will need them in the next projects, but I know from having made some corrections that the following projects are not easy, and I did not want to handicap myself with a gap in the concept of linked lists. So after doing the project the way I saw is most common with 42 students, I decided to do it again with linked lists because I was comfortable with the concept and thought it was a good exercise, and it was not easy but I don't regret it.

All that to say that if you're ever interested in seeing the code or how I worked on the functions, don't hesitate to tell me because I could make a video, I'm going to work on this function again anyway because it may be on the exam, so if you're interested in seeing how I did it maybe with linked lists and or maybe the way I did it the first time, feel free to tell me, once again I hope that it will have helped you and that you will have fun with this project and, in the end, I liked it despite the rather difficult beginnings, and I wish you good luck in your training at 42 and good luck for the future, bye!
